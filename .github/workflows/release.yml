name: Release

on:
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Type of release (terraform-module or non-terraform)'
        required: true
        type: string
      module_path:
        description: 'Path to the Terraform module (only for terraform-module releases)'
        required: false
        type: string
      contributor_type:
        description: 'Type of contributor (Internal or External)'
        required: true
        type: string
      contributor_username:
        description: 'Username of the contributor'
        required: true
        type: string

jobs:
  release:
    name: Release
    runs-on: ubuntu-24.04
    permissions:
      contents: write
      id-token: write
      pull-requests: write

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Read Python version
      id: python-version
      run: |
        PYTHON_VERSION=$(grep '^python ' .tool-versions | awk '{print $2}')
        echo "version=$PYTHON_VERSION" >> $GITHUB_OUTPUT

    - name: Setup Python
      uses: actions/setup-python@v5
      with:
        python-version: ${{ steps.python-version.outputs.version }}

    - name: Generate GitHub App token
      id: generate_token
      uses: tibdex/github-app-token@3beb63f4bd073e61482598c45c71c1019b59b73a
      with:
        app_id: ${{ secrets.GH_APP_ID }}
        private_key: ${{ secrets.GH_APP_PRIVATE_KEY }}

    - name: Install python-semantic-release
      run: pip install -r .github/workflows/requirements-release.txt

    - name: Determine release type & run
      id: run-release
      env:
        GH_TOKEN: ${{ steps.generate_token.outputs.token }}
        GITHUB_TOKEN: ${{ steps.generate_token.outputs.token }}
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
      run: |
        set -eo pipefail

        TYPE="${{ github.event.inputs.release_type }}"
        CONTRIB="${{ github.event.inputs.contributor_type }}"
        USER="${{ github.event.inputs.contributor_username }}"

        notify_slack() {
          local TAG="$1"
          curl -s -X POST -H 'Content-type: application/json' \
            --data "{\"text\":\":rocket: Published *$TAG* ($TYPE) by $USER ($CONTRIB)\"}" \
            $SLACK_WEBHOOK_URL
        }

        git config user.name "caylent-platform-bot[bot]"
        git config user.email "caylent-platform-bot[bot]@users.noreply.github.com"

        if [[ "$TYPE" == "terraform-module" ]]; then
          MODULE="${{ github.event.inputs.module_path }}"
          PREFIX="${MODULE}/v"
          echo "üîß TF release for: $MODULE"

          if [[ ! -d "$MODULE" ]]; then
            echo "‚ùå Module path not found: $MODULE" >&2
            exit 1
          fi

          git fetch origin

          LATEST_TAG=$(git tag --list "${PREFIX}[0-9]*" --sort=-v:refname | head -1)
          if [[ -n "$LATEST_TAG" && ! "$LATEST_TAG" =~ ^${PREFIX}[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "‚ùå Invalid tag format: $LATEST_TAG" >&2
            exit 1
          fi

          if [[ -z "$LATEST_TAG" ]]; then
            CURRENT="0.0.0"
            # For first release, get all commits for the module
            COMMITS=$(git log --oneline -- "$MODULE" || echo "")
          else
            CURRENT="${LATEST_TAG#${PREFIX}}"
            COMMITS=$(git log --oneline "${LATEST_TAG}..HEAD" -- "$MODULE" || echo "")
          fi

          echo "üîç Commits since last tag:"
          echo "$COMMITS"

          # Debug: print each commit line
          echo "--- DEBUG: Commits lines ---"
          echo "$COMMITS" | while read -r line; do echo "> $line"; done
          echo "--- END DEBUG ---"

          # Debug: check grep for feat and fix (match anywhere after hash)
          if echo "$COMMITS" | grep -q ' feat:'; then
            echo "DEBUG: Found feat commit (grep ' feat:')"
            if [[ -z "$LATEST_TAG" ]]; then
              NEXT="0.1.0"
            else
              NEXT=$(echo "$CURRENT" | awk -F. '{print $1"."($2+1)".0"}')
            fi
          elif echo "$COMMITS" | grep -q ' fix:'; then
            echo "DEBUG: Found fix commit (grep ' fix:')"
            if [[ -z "$LATEST_TAG" ]]; then
              NEXT="0.0.1"
            else
              NEXT=$(echo "$CURRENT" | awk -F. '{print $1"."$2"."($3+1)}')
            fi
          else
            echo "DEBUG: No feat or fix commit found (grep did not match)"
            echo "‚ÑπÔ∏è No bump needed."
            exit 0
          fi

          echo "DEBUG: NEXT version will be $NEXT"

          NEW_TAG="${PREFIX}${NEXT}"
          echo "$NEXT" > "${MODULE}/VERSION"
          echo "## $NEW_TAG ($(date +'%Y-%m-%d'))" > "${MODULE}/CHANGELOG.md"
          echo "$COMMITS" | sed 's/^/* /' >> "${MODULE}/CHANGELOG.md"

          # Create release branch and commit changes
          BRANCH_NAME="release-$NEW_TAG"
          git checkout -b "$BRANCH_NAME"
          git add "${MODULE}/VERSION" "${MODULE}/CHANGELOG.md"
          git commit -m "chore(release): $NEW_TAG"
          git push origin "$BRANCH_NAME"

          # Create PR and merge it
          echo "üîÄ Creating release PR..."
          PR_BODY="Automated terraform module release PR for $NEW_TAG"
          PR_URL=$(gh pr create --title "Release $NEW_TAG" --body "$PR_BODY" --base main --head "$BRANCH_NAME")
          echo "Created PR: $PR_URL"
          
          echo "üîÄ Auto-merging release PR..."
          gh pr merge "$PR_URL" --admin --squash

          # Tag the release
          echo "üè∑Ô∏è Creating release tag..."
          git fetch --all
          git checkout main
          git pull origin main
          git tag -a "$NEW_TAG" -m "Release $NEW_TAG"
          git push origin "$NEW_TAG"

          # Clean up release branch
          echo "üßπ Cleaning up release branch..."
          git push origin --delete "$BRANCH_NAME" || true

          notify_slack "$NEW_TAG"
          echo "‚úÖ Terraform release complete"

        else
          echo "üöÄ Non-terraform release with semantic-release v10.1.0"
          git fetch --tags --force
          git fetch origin

          echo "--- DEBUG: Commits since last tag ---"
          LATEST_TAG=$(git describe --tags --abbrev=0 || echo "")
          echo "Latest tag: $LATEST_TAG"
          git log --oneline "$LATEST_TAG"..HEAD || echo "No commits since last tag."
          echo "--- END DEBUG ---"

          # Compute next version using semantic-release
          CURRENT_VERSION=$(cat VERSION || echo "0.0.0")
          RAW_VERSION=$(python -m semantic_release --config .github/semantic-release-config.toml version --print || echo "")
          
          if [[ -z "$RAW_VERSION" ]]; then
            echo "‚ÑπÔ∏è No new version detected by semantic-release, no release needed"
            echo "Current version: $CURRENT_VERSION"
            exit 0
          elif [[ "$RAW_VERSION" != v* ]]; then
            NEW_VERSION="v$RAW_VERSION"
          else
            NEW_VERSION="$RAW_VERSION"
          fi
          
          echo "Computed new version: $NEW_VERSION (from $CURRENT_VERSION)"

          # Only proceed if we have a new version
          if [[ "$NEW_VERSION" == "$CURRENT_VERSION" ]]; then
            echo "‚ÑπÔ∏è Version unchanged, no release needed"
            exit 0
          fi

          # Generate changelog
          echo "üìù Generating changelog..."
          python -m semantic_release --config .github/semantic-release-config.toml changelog

          # Update VERSION file
          echo "$NEW_VERSION" > VERSION

          # Create release branch and commit changes
          BRANCH_NAME="release-$NEW_VERSION"
          git checkout -b "$BRANCH_NAME"
          git add CHANGELOG.md VERSION
          git commit -m "chore(release): $NEW_VERSION"
          git push origin "$BRANCH_NAME"

          # Create PR and merge it
          echo "üîÄ Creating release PR..."
          PR_BODY="Automated release PR for version $NEW_VERSION"
          PR_URL=$(gh pr create --title "Release $NEW_VERSION" --body "$PR_BODY" --base main --head "$BRANCH_NAME")
          echo "Created PR: $PR_URL"
          
          echo "üîÄ Auto-merging release PR..."
          gh pr merge "$PR_URL" --admin --squash

          # Tag the release
          echo "üè∑Ô∏è Creating release tag..."
          git fetch --all
          git checkout main
          git pull origin main
          git tag -a "$NEW_VERSION" -m "Release $NEW_VERSION"
          git push origin "$NEW_VERSION"

          # Clean up release branch
          echo "üßπ Cleaning up release branch..."
          git push origin --delete "$BRANCH_NAME" || true

          notify_slack "$NEW_VERSION"
          echo "‚úÖ Non-terraform release complete: $NEW_VERSION"
        fi

    - name: Show exit status
      run: echo "Release job completed with exit code $?"
